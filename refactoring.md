# 关于重构的重构 - 《重构》第二版导读

近20年过去了，Martin Fowler先生终于推出了新版的《重构》。本人有幸于ThoughtWorks技术雷达十周年峰会现场率先拿到了此书的国内发行版。

在这20年中，软件开发技术发生了很多重要的变化。新的编程语言不断涌现，老的编程语言也加快迭代。主流编程语言大都支持了多种编程范式，函数式编程和面向对象一样成了主流编程语言的标配。对并发的更好支持也已成为主流编程语言新的核心竞争力。于此同时各种软件开发工具也日益现代化，常用的编程IDE都具备了面向重构、测试甚至容器化发布的自动化工具和快捷键。

基于上，很多人都以为新版的重构会迎合时代的变化，焕然一新。然而当我用一整天时间读完全书后，却不禁如释重负。正如本书中文译者熊节先生所说“Flowler先生不仅没有拔高，反而把功夫做的更扎实了”。

确实，无论编程语言的语法如何变化、编程范型如何多元化、工具如何发展，软件设计的目标并没有变：那就是如何在保证软件满足功能和非功能需求的前提下，更易应对变化，更易让人理解和维护。由此所推导出来的软件设计原则更是几十年都没有变，如`高内聚、低耦合`，如`SOLID原则`等。甚至连`GOF设计模式`至今仍然生命力旺盛，除了偶有在一些新的编程范型中出现的新模式以及对原有模式的更简单实现等。此刻再回顾重构技术，它所传授的如何识别代码中的坏味道，以及如何采用小步安全的重构手法逐步将代码演化到更易理解、更易应对变化的状态，正是为了满足软件设计的核心诉求。所以重构应该是和设计模式一样，是一种软件开发中历久而弥新的核心能力。

因此新版在大的结构方面和第一版相似。首先从一个示例开始，先让读者从整体上体会重构的过程和效果。然后Martin给出了重构的具体概念和原则。之后他给读者列出了一份重要的代码坏味道清单并逐一诠释。随后作者用一章来讲述如何搭建对重构来说至关重要的“自动化测试体系”。最后Martin用整本书近四分之三的篇章讲述了几十种常用的重构手法。

而在所谓与时俱进方面，Martin则将更多的精力放在了对细节的持续优化上。首先直接可见的是新版删除了第一版中的最后几章：“大型重构”、“重构，复用与现实”，“重构工具”等，一方面是因为这几章中有些内容在今天看来已不是那么重要，其次是因为所谓的“大型重构”其实仍旧是一系列小的重构手法的合理组合和持续应用。因此在第二版中Martin将重点放到了对重构手法的持续优化上。首先他将原本**22种**代码坏味道调整为**24种**。然后对于重构手法部分，Martin对所有手法重新进行了分类和顺序排布，以便更加内聚和操作连贯。新版保留了第一版中大部分的手法，但是对细节都进行了精致的优化。同时新版删除了一些不再重要的手法，增加了一些对当下比较有用的手法。除这些之外，整本书的示例语言也从Java换成了JavaScript。

本文接下来则着重介绍上述新版中的这些变化点。

## JavaScript

不少人认为第二版中将重构的示例语言由Java变为JavaScript，并不是一种妥当的选择。毕竟JavaScript作为一门动态脚本语言，并不适合较大规模的工业级软件产品。但我个人认为选择JavaScript是经过Martin深思熟虑的。

自从NodeJs将JavaScript带进了服务端开发，JavaScript就变成了一门前后端通吃的语言。此外，ES6标准将JavaScript变成了一门现代语言，语法上同时支持面向对象和函数式范式。最后JavaScript内置多种支持并发编程的特性，它的包管理工具和生态也都建设得非常好。相比其它语言，JavaScript的受众以及可应用的领域相对更加广泛一些。

由于动态语言的灵活性，一般IDE对动态语言的自动化重构支持的并没有静态语言那么好。正因如此，安全的手动重构步骤对对于动态语言来说会显得更有意义。更进一步，熟练掌握手动重构技巧，不仅能更好的理解重构的本质，对在其它主流编程语言下实施重构也非常有价值（例如C、C++、Python等）。

借助动态语言的灵活性，很多重构手法也可以做的更加灵活和简单。例如JavaScript支持在函数内嵌套定义函数，所以应用`Extract Method`手法时，可以先把新提来出来的子函数定义在调用它的函数内部，这样借助函数的闭包性可以减少函数间传递的参数数量。等到真正需要复用该子函数的时候再把它挪到外面。全书中类似的例子还有很多。

在书中，Martin使用了ES6的语法，不仅因为ES6标准为JavaScript引入了类和继承的语法糖，而且在很多细节上也能让代码更加清晰。例如书中对`const`和`let`关键字的大量使用等。但同时Martin也尽量避免使用其他程序员不太熟悉的JavaScript编程风格，例如JS独特的对象模型以及`generator`、`promise`和`await/async`等语法。

最后鉴于使用JavaScript做示例，新版对“构筑测试体系”一章做了较大修改，使用了JavaScript的测试框架`Mocha`和断言库`Chai`一步一步演示了如何构筑自动化测试系统，以辅助重构的安全实施。

## 代码坏味道

学好重构的关键在于掌握三个点：起点、手法和目标（可以参考我之前写的文章“[高效重构（一）：正确理解重构](https://www.jianshu.com/p/3b34f337eaee)”）。

代码的坏味道清单为我们指出了一个重构的起点。当发现代码中有类似清单中所列的坏味道时，就暗示着这是一个可以实施重构的点。可见代码坏味道清单对于重构的重要性。

Martin在新版中对代码坏味道清单进行了重新梳理。下表对比了两版之间的具体差异。

|**第一版**|**第二版**|**变化概要**|
|:-:|:-:|-|
|✗|神秘命名<br>`Mysterious Name`|新版增加，突出了好的命名对于代码的重要性|
|重复代码<br>`Duplicataed Code`|重复代码<br>`Duplicataed Code`|新版删除了对毫不相干的类中出现重复的描述，避免不合时宜的提取非本质重复|
|过长函数<br>`Long Method`|过长函数<br>`Long Function`|基本未变|
|过长参数列表<br>`Long Parameter List`|过长参数列表<br>`Long Parameter List`|新版提供了更多的新的重构解决方案|
|✗|全局数据<br>`Global Data`|新版突出了全局数据对代码耦合性的恶劣影响|
|✗|可变数据<br>`Mutable Data`|新版突出了适宜的不可变性对代码可维护性上的优势|
|发散式变化<br>`Divergent Change`|发散式变化<br>`Divergent Change`|新版提供了更多应对发散式变化的重构方案|
|霰弹式修改<br>`Shotgun Surgery`|霰弹式修改<br>`Shotgun Surgery`|新版提供了更多应对霰弹式修改的重构方案|
|依恋情结<br>`Feature Envy`|依恋情结<br>`Feature Envy`|新版对封装单元的表述不再仅仅针对类，扩展到函数和模块|
|数据泥团<br>`Data Clumps`|数据泥团<br>`Data Clumps`|基本未变|
|基本类型偏执<br>`Primitive Obsession`|基本类型偏执<br>`Primitive Obsession`|新版增加了`类字符类型变量`的危害，并简化了表达方式|
|Switch表达式<br>`Switch Statement`|重复的Switch<br>`Repleated Switch`|新版承认之前“矫枉过正”，重构的核心是要消除**重复**的switch|
|✗|循环语句<br>`Loops`|凸显了在函数式下，循环有了更多的更具语义性的表达方式|
|平行继承体系<br>`Parallel Inheritance Hierarchies`|✗|平行继承体系其实是散弹式修改的特殊形式。为了不再突出面向对象，新版删去|
|冗赘类<br>`Lazy Class`|冗赘的元素<br>`Lazy Element`|新版中体现了冗余的未必只是类，可能是函数、模块等|
|夸夸其谈通用性<br>`Speculative Generality`|夸夸其谈通用性<br>`Speculative Generality`|基本未变|
|临时字段<br>`Temporary Field`|临时字段<br>`Temporary Field`|删除为了特殊算法引入临时字段的情况|
|过长的消息链<br>`Message Chains`|过长的消息链<br>`Message Chains`|基本未变|
|中间人<br>`Middle Man`|中间人<br>`Middle Man`|基本未变|
|狎昵关系<br>`Inappropriate Intimacy`|内幕交易<br>`Insider Trading`|新版中不再仅限于类之间的不恰当耦合，将描述范围扩大到模块|
|过大的类<br>`Large Class`|过大的类<br>`Large Class`|旧版中描述的`GUI大类`已经有些过时了，所以删除了|
|异曲同工的类<br>`Alternative Classes with Different Interfaces`|异曲同工的类<br>`Alternative Classes with Different Interfaces`|新版对所谓类的"异曲同工"解释的更加清晰|
|不完美的类库<br>`Incomplete Library Class`|✗|类库属于可扩展不可修改的代码，新版中把对类库的坏味道辨别和重构删掉了|
|纯数据类<br>`Data Class`|纯数据类<br>`Data Class`|新版提出了例外情况：当纯数据类不可修改且仅用于传递信息时|
|被拒绝的遗赠<br>`Refused Bequest`|被拒绝的遗赠<br>`Refused Bequest`|基本未变|
|注释<br>`Comments`|注释<br>`Comments`|基本未变|

## 重构手法


## 重构示例


## 写在最后


