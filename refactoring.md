# 关于重构的重构 - 《重构》第二版导读

近20年过去了，Martin Fowler先生终于推出了新版的《重构》。本人有幸于ThoughtWorks技术雷达十周年峰会现场率先拿到了此书的国内发行版。

在这20年中，软件开发技术发生了很多重要的变化。新的编程语言不断涌现，老的编程语言也加快迭代。主流编程语言大都支持了多种编程范式，函数式编程和面向对象一样成了主流编程语言的标配。对并发的更好支持也已成为主流编程语言新的核心竞争力。于此同时各种软件开发工具也日益现代化，常用的编程IDE都具备了面向重构、测试甚至容器化发布的自动化工具和快捷键。

基于上，很多人都认为新版的重构会迎合时代的变化，焕然一新。然而当我用一整天时间读完全书后，却不禁如释重负。正如本书中文译者熊节先生所说“Flowler先生不仅没有拔高，反而把功夫做的更扎实了”。

确实，无论编程语言的语法如何变化、编程范型如何多元化、工具如何发展，软件设计的目标并没有变：那就是如何在保证软件满足功能和非功能需求的前提下，更易应对变化，更易让人理解和维护。由此所推导出来的软件设计原则更是几十年都没有变，如`高内聚、低耦合`，如`SOLID原则`等。甚至连`GOF设计模式`至今仍然生命力旺盛，除了偶有在一些新的编程范型中出现的新模式以及对原有模式的更简单实现等。此刻再回顾重构技术，它所传授的如何识别代码中的坏味道，以及如何采用小步安全的重构手法逐步将代码演化到更易理解、更易应对变化的状态，正是为了满足软件设计的核心诉求。所以重构应该是和设计模式一样，是一种软件开发中历久而弥新的核心能力。

因此新版在大的结构方面和第一版相似。首先从一个示例开始，先让读者从整体上体会重构的过程和效果。然后Martin给出了重构的具体概念和原则。之后他给读者列出了一份重要的代码坏味道清单并逐一诠释。随后作者用一章来讲述如何搭建对重构来说至关重要的“自动化测试体系”。最后Martin用整本书近四分之三的篇章讲述了几十种常用的重构手法。

而在所谓与时俱进方面，Martin则将更多的精力放在了对细节的持续优化上。首先直接可见的是新版删除了第一版中的最后几章：“大型重构”、“重构，复用与现实”，“重构工具”等，一方面是因为这几章中有些内容在今天看来已不是那么重要，其次是因为所谓的“大型重构”其实仍旧是一系列小的重构手法的合理组合和持续应用。因此在第二版中Martin将重点放到了对重构手法的持续优化上。首先他将原本**22种**代码坏味道调整为**24种**。然后对于重构手法部分，Martin对所有手法重新进行了分类和顺序排布，以便更加内聚和操作连贯。新版保留了第一版中大部分的手法，但是对细节都进行了精致的优化。同时新版删除了一些不再重要的手法，增加了一些对当下比较有用的手法。

除这些之外，整本书的示例语言也从Java换成了JavaScript。

本文接下来则着重介绍新版中的上述变化。

## JavaScript

不少人认为第二版中将重构的示例语言由Java变为JavaScript，并不是一种妥当的选择。毕竟JavaScript作为一门动态脚本语言，并不适合较大规模的工业级软件产品。但我个人认为选择JavaScript是经过Martin深思熟虑的。

自从NodeJs将JavaScript带进了服务端开发，JavaScript就变成了一门前后端通吃的语言。此外，ES6标准将JavaScript变成了一门现代语言，语法上同时支持面向对象和函数式范式。最后JavaScript内置多种支持并发编程的特性，它的包管理工具和生态也都建设得非常好。相比其它语言，JavaScript的受众以及可应用的领域相对更加广泛一些。

由于动态语言的灵活性，一般IDE对动态语言的自动化重构支持的并没有静态语言那么好。正因如此，安全的手动重构步骤对对于动态语言来说会显得更有意义。更进一步，熟练掌握手动重构技巧，不仅能更好的理解重构的本质，对在其它主流编程语言下实施重构也非常有价值（例如C、C++、Python等）。

借助JavaScript的多范式语法特性以及动态类型的灵活性，很多重构手法可以做的更加简单。例如JavaScript支持在函数内嵌套定义函数，所以应用`Extract Method`手法时，可以先把新提来出来的子函数定义在调用它的函数内部，这样借助函数的闭包性可以减少函数间传递的参数数量。等到真正需要复用该子函数的时候再把它挪到外面。全书中类似的例子还有很多。

在书中，Martin使用了ES6的语法，不仅因为ES6标准为JavaScript引入了类和继承的语法糖，而且在很多细节上也能让代码更加清晰。例如书中对`const`和`let`关键字的大量使用等。但同时Martin也尽量避免使用其他程序员不太熟悉的JavaScript编程风格，例如JS独特的对象模型以及`generator`、`promise`和`await/async`等语法。

因为使用JavaScript的缘故，新版对“构筑测试体系”一章做了较大修改。Martin演示了如何使用JavaScript的测试框架`Mocha`和断言库`Chai`构筑自动化测试系统，以支持重构的安全实施。

## 代码坏味道

学好重构的关键在于掌握三个点：起点、手法和目标（可以参考我之前写的文章：[《高效重构（一）：正确理解重构》](https://www.jianshu.com/p/3b34f337eaee)）。

代码的坏味道清单为我们指出了一个重构的起点。当发现代码中有类似清单中所列的坏味道时，就暗示着这是一个应该实施重构的地方。可见代码坏味道清单对于重构的重要性。

Martin在新版中对代码坏味道清单进行了重新梳理。下表对比了两版之间的具体差异。

|**第一版**|**第二版**|**变化概要**|
|:-:|:-:|-|
|✗|神秘命名<br>`Mysterious Name`|新版增加，突出了好的命名对于代码的重要性|
|重复代码<br>`Duplicataed Code`|重复代码<br>`Duplicataed Code`|新版删除了对毫不相干的类中出现重复的描述，避免不合时宜的提取非本质重复|
|过长函数<br>`Long Method`|过长函数<br>`Long Function`|基本未变|
|过长参数列表<br>`Long Parameter List`|过长参数列表<br>`Long Parameter List`|新版提供了更多的新的重构解决方案|
|✗|全局数据<br>`Global Data`|新版突出了全局数据对代码耦合性的恶劣影响|
|✗|可变数据<br>`Mutable Data`|新版突出了适宜的不可变性对代码可维护性上的优势|
|发散式变化<br>`Divergent Change`|发散式变化<br>`Divergent Change`|新版提供了更多应对发散式变化的重构方案|
|霰弹式修改<br>`Shotgun Surgery`|霰弹式修改<br>`Shotgun Surgery`|新版提供了更多应对霰弹式修改的重构方案|
|依恋情结<br>`Feature Envy`|依恋情结<br>`Feature Envy`|新版对封装单元的表述不再仅仅针对类，扩展到函数和模块|
|数据泥团<br>`Data Clumps`|数据泥团<br>`Data Clumps`|基本未变|
|基本类型偏执<br>`Primitive Obsession`|基本类型偏执<br>`Primitive Obsession`|新版增加了`类字符类型变量`的危害，并简化了表达方式|
|Switch表达式<br>`Switch Statement`|重复的Switch<br>`Repleated Switch`|新版承认之前“矫枉过正”，重构的核心是要消除**重复**的switch|
|✗|循环语句<br>`Loops`|凸显了在函数式下，循环有了更多的更具语义性的表达方式|
|平行继承体系<br>`Parallel Inheritance Hierarchies`|✗|平行继承体系其实是散弹式修改的特殊形式。为了不再突出面向对象，新版删去|
|冗赘类<br>`Lazy Class`|冗赘的元素<br>`Lazy Element`|新版中体现了冗余的未必只是类，可能是函数、模块等|
|夸夸其谈通用性<br>`Speculative Generality`|夸夸其谈通用性<br>`Speculative Generality`|基本未变|
|临时字段<br>`Temporary Field`|临时字段<br>`Temporary Field`|删除为了特殊算法引入临时字段的情况|
|过长的消息链<br>`Message Chains`|过长的消息链<br>`Message Chains`|基本未变|
|中间人<br>`Middle Man`|中间人<br>`Middle Man`|基本未变|
|狎昵关系<br>`Inappropriate Intimacy`|内幕交易<br>`Insider Trading`|新版中不再仅限于类之间的不恰当耦合，将描述范围扩大到模块|
|过大的类<br>`Large Class`|过大的类<br>`Large Class`|旧版中描述的`GUI大类`已经有些过时了，所以删除了|
|异曲同工的类<br>`Alternative Classes with Different Interfaces`|异曲同工的类<br>`Alternative Classes with Different Interfaces`|新版对所谓类的"异曲同工"解释的更加清晰|
|不完美的类库<br>`Incomplete Library Class`|✗|类库属于可扩展不可修改的代码，新版中把对类库的坏味道辨别和重构删掉了|
|纯数据类<br>`Data Class`|纯数据类<br>`Data Class`|新版提出了例外情况：当纯数据类不可修改且仅用于传递信息时|
|被拒绝的遗赠<br>`Refused Bequest`|被拒绝的遗赠<br>`Refused Bequest`|基本未变|
|注释<br>`Comments`|注释<br>`Comments`|基本未变|

如上，除了一些语言上的调整外，主要的变化如下：
- 更加注重对细节的打磨。新增一些小的明确的坏味道（如`Mysterious Name`、`Global Data`），去除了一些大的、稍显模糊或者可被分解的坏味道（如`Parallel Inheritance Hierarchies`、`Inappropriate Intimacy`）；
- 修正了一些之前不准确的描述。例如将`Switch Statement`更改为`Repleated Switch`。
  > 这个修改非常有意思，Martin在书中也承认当年有些矫枉过正了！想当年多少人看完重构，致力于消除代码中的每一处`if-else`和`swtich`！殊不知对于缺乏反射的静态语言，即使采用多态替换了条件分支，但是最后在工厂方法里拼装对象的时候却必须得存在一个条件分支。这次总算是拨乱反正了！
- 弱化了面向对象和类的分量，更多使用兼顾通用化的定义（例如使用`模块`一词替代`类`）。
- 在某些局部的点上，优先推荐了一些函数式的解决方案，例如`把loops替换为管道`。
  > 不过对于新版中直接将`loops`定义为一种坏味道，个人认为是Martin新的一次矫枉过正。虽然管道和流在某些场景下比loops语义更清晰，但是不可否认在一些简单的场景下loops更加符合一般程序员的思维习惯。所以这还得看具体的场景，一刀切有些不妥！不知道下一版中Martin会不会承认这类似第一版中的`Switch Statement`一样，是一次故意的“矫枉过正”。

## 重构手法

正确的实施重构手法是高效又安全的达成重构目标的保障。

很多人认为学习重构只要掌握背后的思想就足够了，其详细繁琐的操作手法并不重要。于是乎现实中很多人在实际操作重构的过程中章法全无，一旦开始半天停不下来，代码很多时候处于不可编译或者测试不能通过的状态。有时改的出错了很难再使代码回到初始状态，只能推倒重来! 

实际上重构是一项非常注重操作过程的技术，能够正确合理地使用重构手法，安全、小步、高效地完成代码修改，是评价重构能力的核心标准。否则Martin老先生也不值得花费多达四分之三的篇章对重构手法浓墨重彩了。

新版将重构手法从原来的68种调整到61种。由于具体的重构手法数量较多，这里就不一一对比了，只介绍一些重要的变化点。

- 为了让重构手法间衔接得更加顺畅，新版中重新调整了重构手法的编排顺序；
  > 新版中将最基本的常用重构放到了一章，起名叫做”第一组重构“，然后按照”封装“、”搬迁“、”数据“、”逻辑“、”API“以及”继承关系“的顺序和分类，重新组织了其它所有的重构手法；

- 为了保持概念的内聚和统一性，对一些重构手法进行了合并；
  > 例如将`函数改名（Rename Method）`、`添加参数（Add Parameter）`和`移除参数（Remove Parameter）`统一合并为`改名函数声明（Change Function Declaration）`，类似的还有很多；

- 通过调整原有的重构命名或者新增新的重构手法，让重要的重构同时存在正向和反向手法，以便可以在操作时更加灵活地决定重构的方向；
  > 例如将原来的`内联临时变量（Inline Temp）`和`引入解释性变量（Introduce Explaining Variable） `改名为`内联变量（Inline Variable）`和`提炼变量（Extract Variable）`；
    将`以函数取代参数（Replace Parameter with Methods）`修改为`以查询取代参数（Replace Parameter with Query）`，并为其引入反向重构`以参数取代查询（Replace Query with Parameter）`；

- 为了能够介绍的更加清晰，每种手法的介绍里面增加了`曾用名`、`反向重构`和`示意图`
  > - `曾用名`指出该重构在第一版中的原有命名；
  > - `反向重构`指出该重构对应的的反向操作的手法名称，为重构之间建立起互逆关系；
  > - `示意图`是Martin为每个重构手法画的一副小图，通过形象化的方式展现该每个重构的效果。
  > - 另外，我建议在阅读时，除了关注每个重构手法的`做法`和`范例`外，最好能把`动机`部分也好好阅读下。`动机`部分介绍了”为什么要做“以及”什么时候不该“做这个重构，里面的很多思考都很有启发意义。

- 由于编程范式的多元化，新版中弱化了面向对象，尽可能的让重构手法更加的具有普适性
  > 例如将`引入Null对象（Introduce Null Object`改为`引入特例（Introduce Special Case）`

- 考虑到”组合优于继承“，调整删除了一些和"重构到继承"相关的重构手法；
  > 例如删除了`提炼子类（Extract Subclass）`和`以继承取代委托（Replace Delegation with Inheritance）`等

- 由于JavaScript语法特性，删除了一些不适用的重构手法；
  > 例如删除了`提炼接口（Extract Interface）`和`封装向下转型（Encapsulate Downcast）`等

- 在某些重构的操作步骤里，利用了JavaScript的语法特性简化了重构的操作过程；
  > 本书经常使用两类JavaScript的语法特征：
    - JavaScript支持函数式编程，允许函数作为参数和返回值，允许在函数里面嵌套定义函数以及支持匿名函数和闭包。所以在`提炼函数（Extract Function）`手法里面，先将提炼出来的新函数定义在调用它的函数的里面，这样借助函数的闭包性可以减少函数间传递的参数数量，等到真正需要复用该子函数的时候再将它挪出；而`以管道取代循环（Replace Loop with Pipeline）`重构，则完全依赖于语言支持匿名函数和闭包性才能做到。
    - JavaScript作为一门动态语言，支持灵活的对象模型。新版中很多重构手法，会在重构的中间过程往对象中临时加入新的字段或者函数，以方便后面的重构过程。具体见`拆分阶段（Split Phase）`和`函数组合成变换（Combine Functions into Transform）`等；

对于重构手法部分，Martin进行了精心的调整，上述只是我总结新版中较明显的变动，还有更多细致的修改还是请仔细品读原书。最后要说的是，书中介绍了多达六十多种重构手法，普通人很难把所有的步骤都牢记于心。所以可以把此书当做一本重构名录，在实践过程中如果忘记了某些具体的操作步骤，可以再翻书查阅。另外相信经过反复阅读和实践，慢慢就会掌握重构手法背后普遍的原理和规律，做到”手中无剑，心中有剑“。我曾把所有的重构手法归结为了四类基本手法，最后浓缩成了两个核心操作，并给出了在重构时合理编排重构步骤的推理方法以及利用`锚点`来简化重构操作的技巧。具体见[《高效重构（二）：掌握重构手法》](https://www.jianshu.com/p/58f4c61b1cb3)。

## 重构示例


## 写在最后


